import itertools, threading, time

class ProxyHandler:
    def __init__(self, proxy_list, p_type="http", threshold=3, cooldown_base=60):
        self.lock = threading.Lock()
        self.threshold = threshold
        self.cooldown_base = cooldown_base
        self.p_type = p_type
        # State: {proxy: [fails, last_fail_time, cooldown_until]}
        self.proxies = {p.strip(): [0, 0, 0] for p in proxy_list if p.strip()}
        self.active_pool = list(self.proxies.keys())
        self.cycle = itertools.cycle(self.active_pool) if self.active_pool else None

    def get_proxy(self):
        with self.lock:
            if not self.active_pool: return None, None
            now = time.time()
            for _ in range(len(self.active_pool)):
                p = next(self.cycle)
                stats = self.proxies[p]
                
                # Logic: Is it under threshold OR has it recovered from cooldown?
                if stats[0] < self.threshold or now > stats[2]:
                    # Auto-recovery if cooldown passed
                    if now > stats[2] and stats[0] >= self.threshold:
                        stats[0] = 0 # Reset fails
                    
                    prefix = f"{self.p_type}://" if "://" not in p else ""
                    return {"http": f"{prefix}{p}", "https": f"{prefix}{p}"}, p
            return None, None

    def report_bad(self, p_raw):
        with self.lock:
            if p_raw in self.proxies:
                now = time.time()
                self.proxies[p_raw][0] += 1 # Increment fails
                self.proxies[p_raw][1] = now # Last fail
                # Exponential backoff for proxy cooldown
                wait = self.cooldown_base * (2 ** (self.proxies[p_raw][0] - 1))
                self.proxies[p_raw][2] = now + wait


